\subsection{C-Code}

\noindent {\ttfamily Hopping\_Matrix(int ieo, int l, int k)}:\\
Files: {\ttfamily Hopping\_Matrix.c|h}.\\
Here the Hopping Matrix is implemented.
\[
\kappa\sum_\mu \delta_{x,y+\hat\mu}(1+\gamma_\mu)
\]
It connect even (odd) sites in {\ttfamily l} with odd  (even) sites in {\ttfamily k}
if {\ttfamily ieo} is set to {\ttfamily EO} ({\ttfamily
  OE}). {\ttfamily EO} and {\ttfamily OE} are defined in {\ttfamily
  Hopping\_Matrix.h}.

\noindent {\ttfamily mul\_one\_pm\_imu\_inv(int l, double sign)}:\\
Files: {\ttfamily tm\_operators.c}.\\
This multiplies {\ttfamily l} with 
\[
l = (M_{ee}^{\pm})^{-1} l\, ,
\]
where the sign of $M_{ee}^{\pm}$ is set corresponding to {\ttfamily
  sign}. This connects even with even or odd with odd sites.

\noindent{\ttfamily mul\_one\_pm\_imu\_sub\_mul\_gamma5(int l, int k, int j,
double sign)}:\\
Files: {\ttfamily tm\_operators.c}.\\
This performs:
\[
l = \gamma_5 ((1 \pm i \mu \gamma_5)k - j)\, ,
\]
where the sign is set corresponding to {\ttfamily sign}.

\noindent{\ttfamily mul\_one\_pm\_imu\_sub\_mul(int l, int k, int j,
double sign)}:\\
Files: {\ttfamily tm\_operators.c}.\\
This performs:
\[
l = ((1 \pm i \mu \gamma_5)k - j)\, ,
\]
where the sign is set corresponding to {\ttfamily sign}.

\noindent{\ttfamily Qtm\_plus\_psi(int l, int k)}:\\
Files: {\ttfamily tm\_operators.c|h}.\\
This implements:
\[
\hat Q_{+} = \gamma_5(M_{oo}^+ - M_{oe}(M_{ee}^+ )^{-1}M_{eo})\, .
\]
The Operator is applied to {\ttfamily k} and the result is stored in
{\ttfamily l}. $\hat Q_{-}$ is implemented in {\ttfamily
  Qtm\_minus\_psi(int l, int k)}.

\noindent{\ttfamily Mtm\_plus\_psi(int l, int k)}:\\
Files: {\ttfamily tm\_operators.c|h}.\\
This implements:
\[
\hat \gamma_5Q_{+} = (M_{oo}^+ - M_{oe}(M_{ee}^+ )^{-1}M_{eo})\, .
\]
The Operator is applied to {\ttfamily k} and the result is stored in
{\ttfamily l}. $\hat \gamma_5Q_{-}$ is implemented in {\ttfamily
  Mtm\_minus\_psi(int l, int k)}.

\noindent{\ttfamily Qtm\_pm\_psi(int l, int k)}:\\
Files: {\ttfamily tm\_operators.c|h}.\\
This implements:
\[
\hat Q_{+} \hat Q_{-}\, .
\]
The Operator is applied to {\ttfamily k} and the result is stored in
{\ttfamily l}.

\noindent{\ttfamily H\_eo\_tm\_inv\_psi(int l, int k, int ieo, double
  sign)}:\\
Files:  {\ttfamily tm\_operators.c|h}.\\
This implements:
\[
l = (M_{ee|oo}^\pm)^{-1} M_{eo|oe} k\, .
\]
The sign is set corresponding to {\ttfamily sign}. Setting {\ttfamily
  ieo} to {\ttfamily EO} ({\ttfamily OE}) means using $M_{eo}$
($M_{oe}$) and $M_{ee}$ ($M_{oo}$).

\subsection{Chronological Inverter}

The implementation of the chronological inverter \cite{Brower:1995vx}
can be found in the direction {\ttfamily solver} in the files
{\ttfamily chrono\_guess.c|h}. These files define basically two
funtions:

\noindent{\ttfamily void chrono\_add\_solution(spinor * const trial, spinor
  ** const v, int index\_array[], const int N, const int \_n, const
  int V)}\\
This function adds the spinor {\ttfamily trial} to the stack of
already existing solutions. These are stored in the array {\ttfamily
  v}. In the integer array {\ttfamily index\_array} the current order
of the spinor fields in {\ttfamily v} is stored. {\ttfamily N} must
contain the maximal number of solutions to store in {\ttfamily v},
{\ttfamily \_n} contains the current index and {\ttfamily V} the volume.

The memory for {\ttfamily v} must be allocated by the user and it must
be of size {\ttfamily V*N}. The bookholding with {\ttfamily \_n} and
{\ttfamily index\_array} is done by the function and should not be
changed by the user elsewhere.

\noindent{\ttfamily int chrono\_guess(spinor * const trial, spinor *
  const phi, spinor ** const v, int index\_array[],
  const int \_N, const int \_n, const int V, matrix\_mult f)}\\
This fuction returns in the spinor {\ttfamily trial} a trial guess
computed with the chronological guess algorithm. Apart from the
parametes explained already above: {\ttfamily phi} is the source
spinor and {\ttfamily matric\_mult} is a pointer to the matrix to be
inverted.

Note that the chronological solver guess uses lapack functions and is
switched off when it is not available, and as well as when the history
length is chosen to be zero, a zero spinor field is returned by the
chrono guess function. See also input parameters concerning CSG.

\subsection{$\gamma$ matrices}
\label{gammas}
$\gamma_5$ ist defined as follows:
\[
  \gamma_5 =
  \begin{pmatrix}
    +1 & 0 & 0 & 0 \\
    0 & +1 & 0 & 0 \\
    0 & 0 & -1 & 0 \\
    0 & 0 & 0 & -1 \\    
  \end{pmatrix}\ .
\]

In the operator the following notation for
the matrices is used:
\[
\begin{split}
  \gamma_0 = -\begin{pmatrix}
    0 & 0 & +1 & 0 \\
    0 & 0 & 0 & +1 \\
    +1 & 0 & 0 & 0 \\
    0 & +1 & 0 & 0 \\
  \end{pmatrix},\quad
  \gamma_1 = -\begin{pmatrix}
    0 & 0 & 0 & +i \\
    0 & 0 & +i & 0 \\
    0 & -i & 0 & 0 \\
    -i & 0 & 0 & 0 \\    
  \end{pmatrix},\\
  \gamma_2 = -\begin{pmatrix}
    0 & 0 & 0 & +1 \\
    0 & 0 & -1 & 0 \\
    0 & -1 & 0 & 0 \\
    +1 & 0 & 0 & 0 \\   
  \end{pmatrix},\quad
  \gamma_3 = -\begin{pmatrix}
    0 & 0 & +i & 0 \\
    0 & 0 & 0 & -i \\
    -i & 0 & 0 & 0 \\
    0 & +i & 0 & 0 \\
  \end{pmatrix}\ .\\
\end{split}
\]



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
