\section{Input parameter for main program}

The main programs are called {\ttfamily hmc\_tm} for the HMC algorithm
and {\ttfamily invert} for even odd preconditioned inversion. They can
be called with
\begin{itemize}
\item {\ttfamily -f filename}:\\
  where {\ttfamily filename} is the name of the input file to be
  used. The default name is {\ttfamily hmc.input}.

\item {\ttfamily -o name}:\\
  {\ttfamily name} will be used as name for several output files. This
  files differ by their suffix. Default for {\ttfamily name} is
  {\ttfamily output}.

\item {\ttfamily -?|-h}:\\
  This will produce help output and exit then.
  
\end{itemize}

There are several input parameters read from an input file. The parser is contained in the file {\ttfamily gwc/src/bin/read\_input.l}. The file {\ttfamily read\_input.l} is converted to {\ttfamily read\_input.c} using {\ttfamily flex} and defines the following function:

Definition:\\
\begin{ttfamily}
  int read\_input(char * conf\_file)
\end{ttfamily}\\

\begin{tabular}[h]{l l l}
{\ttfamily conf\_file} & in & string with input file name\\ 
\end{tabular}

The functions returns $0$, if no error occurs, $2$, if the input file
could not be opened. If no input file could be opened or if there is
no value given in the input file for a paramter, default values are
used. All default values can be found in the file {\ttfamily
  gwc/src/bin/default\_input\_values.h}. The syntax is mostly
{\ttfamily keyword = value} and {\ttfamily keyword} must be at the
beginning of the line. Comments starting with {\ttfamily \#} and empty
lines are allowed. The order of the lines is not importand as long as
every keyword appears only once.  If it appears more than once, the
last appearance becomes valid. The parser is case-insensitive.

In the following a list of the currently (possibly incomplete)
supported general input paramters: 
\begin{enumerate}
\item {\ttfamily T}:\\
  The global time extension of the lattice. Default is $4$.

\item {\ttfamily L}:\\
  The global spatial extension of the lattice. Default is $4$.

\item {\ttfamily LX}:\\
  The global spatial x-extension of the lattice. Default is $4$.

\item {\ttfamily LY}:\\
  The global spatial y-extension of the lattice. Default is $4$.

\item {\ttfamily LZ}:\\
  The global spatial z-extension of the lattice. Default is $4$.

\item {\ttfamily NrXProcs}:\\
  The number of processors in x-direction in case of two dimensional
  parallelisation. This has no effect in case of one dimensional
  parallelisation. In case of two dimensional parallelisation it must
  be properly set. The number of processors in time direction is
  automatically computed.

\item {\ttfamily NrYProcs, NrZProcs}:\\
  See {\ttfamily NrXProcs}.

\item {\ttfamily seed}:\\
  The seed for the random number generator. Default value is $123456$.

\item {\ttfamily beta}:\\
  The invers coupling $\beta$. Default value is $5.2$.

\item {\ttfamily kappa}:\\
  The $\kappa$ value. Default is $0.12$.

\item {\ttfamily 2KappaMu}:\\
  Twisted mass parameter (the physical one) for twisted mass
  action. This is for internal reasons $2\kappa\mu$.

\item {\ttfamily Startcondition}:\\
  The starting condition for a run. Possible values are {\ttfamily
    hot, cold, restart, continue}. Default is {\ttfamily
    cold}. Restart uses the seed to reset the random number
  generator. In case of {\ttfamily continue} the programme uses the
  file {\ttfamily .nstore\_counter} to get the information about from
  where to read the gauge and the random number status. If this file
  does not exist (its written in the course of the HMC) then the input
  parameter described here are used instead.

\item {\ttfamily Measurements}:\\
  Number of measurements in units of trajectories to be done. Default
  value is $3$. For the {\ttfamily invert} programme this counts the
  number of gauge configurations to invert on.

\item {ThermalisationSweeps}:\\
  As longer as the number of trajectories is smaller than this number
  the acceptance test will be discarded. This might help to faster
  equilibrate the system.

\item {\ttfamily Nskip}:\\
  Number of produced configurations to skip (i.e. not written to
  disk). Default value is $5$. For the {\ttfamily invert} programme
  this counts the number of gauge configurations to skip in between
  adjacent inversions.

\item {\ttfamily InitialStoreCounter}:\\
  Start with value to label measurements. Default is $0$. Can be also
  set to {\ttfamily readin} which causes to let the code check for a
  file {\ttfamily .nstore\_counter} and reads the initial value from
  this file. If it is not existing, the counter will be set to $0$.

\item {\ttfamily GaugeConfigInputFile}:\\
  Name of input file for the gauge field. Default is {\ttfamily conf}

\item {\ttfamily Indices=n-m}:\\
  Compute only components $n$ to $m$ of the quark propagator. $n,m$ must
  be in $[0,11]$. If the start index is not zero the data will be
  appended to the propagator file. The program takes not care of the
  order, the data is just appended! This parameter has only
  effect for executable {\ttfamily invert}.

\item {\ttfamily SplittedPropagator}:\\
  If set to yes the propagators will written splitted to disk: one
  file per spinor color component. Default is {\ttfamily yes}.

\item {\ttfamily SplittedSource}:\\
  If set to yes every source is expected to be stored in a seperate file.
  Default is {\ttfamily yes}.

\item {\ttfamily BCAngleT=x}:\\
  This set the angle in
  time direction to $\theta_t = 2\pi x$. Default value is
  zero. A value of $1$ would mean antiperiodic boundary conditions in
  time for the fermion fields.

\item {\ttfamily UseRelativePrecision}:\\
  Possible values {\ttfamily yes, no}. Indicates whether relative
  precision is used in the inversions for the force and the acceptance
  computation. Default is no.

\item {\ttfamily DebugLevel}:\\
  If set to a value larger than $0$ this causes verbose output:
  \begin{enumerate}
  \item forces are printed out.
  \end{enumerate}

\item {\ttfamily BCGstabMaxIter}:\\
  The maximal number of iterations in the BiCGstab solver.

\item {\ttfamily CGMaxIter}:\\
  The maximal number of iterations in the CG solver.

\item {\ttfamily ReversibilityCheck}:\\
  If set to {\ttfamily yes} the program will perform a check of
  reversibility violation in the integrator by integrating back in
  time. If not yet existing, the program creates a file {\ttfamily
    return\_check.data} in which it stores the reversibility violation
  as the difference in the Hamiltonian.

\item {\ttfamily ReversibilityCheckIntervall}:\\
  Here one can specify the intervall in terms of trajectories the
  program should check the reversibility violation.

\item {\ttfamily GaugeConfigRead|WritePrecision}:\\
  Read/Write gauge configurations in single (32) or double double (64)
  precision. Default is 64.

\item {\ttfamily GMRESMParameter}:\\
  Krylov subspace size $m$ in GMRES($m$) and such like iterative
  solvers. Not yet working!

\item {\ttfamily GMRESDRNrEv}:\\
  Number of eigenvalues to be deflated in GMRES-DR iterative
  solver. Not yet working!

\item {\ttfamily SourceFormat}:\\
  deprecated, has no effect anymore.

\item {\ttfamily SolverFlag}:\\
  Sets the solver to be used. Possible values are among others
  {\ttfamily CG, BiCGstab, CGS, GMRES, PCG}. This parameter has only
  effect for executable {\ttfamily invert}.

\item {\ttfamily SolverPrecision}:\\
  Stopping criterion for solver in programme invert. The squared
  residue must be set. This parameter has only
  effect for executable {\ttfamily invert}.

\item {\ttfamily ReadSource}:\\
  If set to yes, then the source vector is read from a file. This
  parameter has only effect for executable {\ttfamily invert}.

\item {\ttfamily SourceInputFilename}:\\
  Base filename of the source vector to be read in. The filename will
  be constructed as {\ttfamily basefilename.is*ic},
  unless propagator is not splitted, i.e. stored in only one file,
  which has the name {\ttfamily basefilename} then.
  Parameter has only effect for executable {\ttfamily invert}.

\item {\ttfamily SourceTimeSlice}:\\
  not used right now.
  The time slice of the source to be read (in case of cmi format). At
  the moment used only for
  the automatic construction of filenames. The filename will then be
  constructed as {\ttfamily basefilename.nstore.ts.index}.
  {\ttfamily SourceTimeSlice} must be set to something
  smaller than 0 or larger than T in order to let the code not
  automatically construct the filenames. The filename will then
  consist only of the base filename. This parameter has only
  effect for executable {\ttfamily invert}.

\item {\ttfamily UseSloppyPrecision}:\\
  Use a reduced precision Dirac operator in the MC part of the
  HMC. Possible values are yes and no, the latter being the
  default. This could be possibly used in the invert code along the 
  lines of {\ttfamily hep-lat/0609023} in the future.

\item {\ttfamily ComputeEVs}:\\
  compute eigenvalues and vectors before inversion in invert. Values
  can be no, yes and readin. In the latter case the eigenvalues and
  vectors are only read from disk, if possible. In case of yes it is
  also tried to read them from disk, but they are also recomputed, to
  a possibly higher precision.

\item {\ttfamily NoEigenvalues}:\\
  number of eigenvalues to compute.

\item {\ttfamily EigenvaluePrecision}:\\
  precision for eigenvalues.

\item {\ttfamily SourceLocation}:\\
  integer indicating the location of the source. The location is computed as
  {\ttfamily SourceLocation = z+L*y+L*L*x+L*L*L*t}.

\item {\ttfamily UseStoutSmearing}:\\
  Whether or not to stout smear the configuration before inversion.

\item {\ttfamily StoutRho} and {\ttfamily StoutNoIterations}:\\
  Stout smearing parameter.

\item {\ttfamily UseEvenOdd}:\\
  Whether or not to use even/odd preconditioning in the invert
  programme.

\item {\ttfamily WritePropagatorFormat} or {\ttfamily PropagatorType}:\\
  The type in which to store the propagator. There are 
  \begin{itemize}
  \item {\ttfamily DiracFermion\_Sink}
  \item {\ttfamily DiracFermion\_Source\_Sink\_Pairs}
  \item {\ttfamily DiracFermion\_ScalarSource\_TwelveSink}
  \item {\ttfamily DiracFermion\_ScalarSource\_FourSink}
  \end{itemize}
  available. However, only the first two are implemented so far.

\item {\ttfamily PerfromOnlineMeasurements}:\\
  Perform some useful measurements online. This includes so far the
  $\langle PP\rangle$ and the $\langle PA\rangle$ correlators.

\item {\ttfamily OnlineMeasurementsFreq}:\\
  The frequency in units of trajectories with which to perform online
  measurements. 

\end{enumerate}

\noindent $n_f=2+1+1$ related input parameters, where the heavy part of the actions
reads
\begin{equation}
  \label{eq:haction}
  S_{F,h} = \bar\psi_h\left[ \delta_{x,y}(1+i\gamma_5\bar\mu\tau^3 +
    \bar\epsilon\tau^1)
  - \kappa\sum_\mu \delta_{x,y+\mu}(1+\gamma_\mu)U_{y,\mu}\right] \psi_h
\end{equation}
For more details see also the file {\ttfamily Status-Phmc.pdf} in the
very same directory.
\begin{enumerate}
\item {\ttfamily 2KappaMuBar}:\\
  The average mass of the heavy doublet multiplied with $2\kappa$

\item {\ttfamily 2KappaEpsBar}:\\
  The splitting mass multiplied with $2\kappa$

\end{enumerate}

\subsection{Specifying the Action to Simulate}

Following the CHROMA notation we call every part in the action a
monomial. A monomial is added to the action in the input file in the
following way:
\begin{verbatim}
BeginMonomial TYPE
  Option = value
EndMonomial
\end{verbatim}
{\ttfamily TYPE} can be one of the following
\begin{itemize}
\item {\ttfamily DET}: pseudo fermion representation of the (mass degenerate)\\
  \[
  \det(Q^2(\kappa) + \mu^2)
  \]
\item {\ttfamily DETRATIO}: pseudo fermion representation of\\
  \[
  \det(Q^2(\kappa) + \mu^2)/det(Q^2(\kappa_2) + \mu_2^2)
  \]
\item {\ttfamily GAUGE}:\\
  \[
  \frac{\beta}{3}\sum_x\left(  c_0\sum_{\substack{
        \mu,\nu=1\\1\leq\mu<\nu}}^4\{1-\re\tr(U^{1\times1}_{x,\mu,\nu})\}\Bigr. 
    \Bigl.\ +\ 
    c_1\sum_{\substack{\mu,\nu=1\\\mu\neq\nu}}^4\{1
    -\re\tr(U^{1\times2}_{x,\mu,\nu})\}\right)\,  ,
  \]
\item {\ttfamily NDPOLY}: polynomial representation of the (possibly
  non-degenerate) split doublet\\
  \[
  \det(Q_{nd}(\bar\epsilon, \bar\mu)
  \]
\end{itemize}

Each of them has different options:
\begin{itemize}
\item {\ttfamily DET}:
  \begin{itemize}
  \item {\ttfamily 2KappaMu}
  \item {\ttfamily Kappa}
  \item {\ttfamily Timescale}: the timescale on which to integrate
    this monomial. Counting starts from zero up to the total number of
    timescales minus 1.
  \item {\ttfamily CSGHistory}: the maximal number of vectors to store
    for the chronolical predictor (for CG and BiCGstab), default $0$.
  \item {\ttfamily CSGHistory2}: the maximal number of vectors to store
    for the second chronolical predictor (for BiCGstab only), default
    $0$.
  \item {\ttfamily ForcePrecision}: the solver precision used in the
    force computation
  \item {\ttfamily AcceptancePrecision}: the solver precision used in the
    acceptance and heatbath
  \item {\ttfamily MaxSolverIterations}: default is $5000$
  \item {\ttfamily Solver}: the solver to be used, either CG or
    BiCGstab. Default is CG.
  \item {\ttfamily Name}: a name to be assigned to the monomial. The
    default is {\ttfamily DET}
  \end{itemize}
\item {\ttfamily DETRATIO}: the same as for {\ttfamily DET}, but in
  addition:
  \begin{itemize}
  \item {\ttfamily 2KappaMu2}
  \item {\ttfamily Kappa2}
  \item {\ttfamily Name}: a name to be assigned to the monomial. The
    default is {\ttfamily DETRATIO}
  \end{itemize}
\item {\ttfamily GAUGE}: the $\beta$-value is taken from the general
  input parameter, what is important here is to choose the timescale
  and the use of the rectangular staples.
  \begin{itemize}
  \item {\ttfamily Timescale}: the timescale on which to integrate
    this monomial. Counting starts from zero up to the total number of
    timescales minus 1.
  \item {\ttfamily UseRectangleStaples}: can be yes or no, indicating
    whether to use also the rectangle staples. No corresponds to pure
    Wilson plaquette. Default is no.
  \item {\ttfamily c1}: the value of the parameter $c_1$. The
    coefficient $c_0$ is computed from $c_0 = 1-8c_1$.
  \item {\ttfamily Name}: a name to be assigned to the monomial. The
    default is {\ttfamily GAUGE}
  \end{itemize}
  There is maximally one allowed for this type.
\item {\ttfamily NDPOLY}: more a dummy monomial so far, but switches
  on the PHMC part for the non-degenerate heavy doublet and lets you
  specify the timescale on which to integrate this.
  \begin{itemize}

  \item {\ttfamily Timescale}: the timescale on which to integrate
    this monomial. Counting starts from zero up to the total number of
    timescales minus 1.

  \item {\ttfamily Name}: a name to be assigned to the monomial. The
    default is {\ttfamily NDPOLY}

  \item {\ttfamily ComputeEVFreq}:
    If you want to calculate the eigenvalues every n'th trajectory
    then set this parameter to n if you want no eigenvalues set this to 0
    during thermalization you should set this to 1 or 2 to follow the evolution
    of smallest and largest eigenvalue to adjust the approximation interval
    of the polynomial

  \item {\ttfamily ComputeOnlyEVs}: Computes only once at the very
    beginning of the run the eigenvalues of the heavy split operator
    and exits.

  \item {\ttfamily StildeMin}: lower bound for the approximation interval of the polynomial

  \item {\ttfamily StildeMax}:
    upper bound for the approximation interval of the polynomial

  \item {\ttfamily DegreeOfMDPolynomial}:
    degree of the less precise polynomial $P$. Must be identical to the
    degree used to compute the roots.

  \item {\ttfamily PrecisionPtilde}:
    Precision of the more precise polynomial $\tilde P$ used in the
    heat-bath and the acceptance step of the PHMC.

  \item {\ttfamily PrecisionHfinal}:
  \end{itemize}
  So far there is maximally one allowed for this type.
\end{itemize}

\subsection{The Integrator}

The Integrator can be specified similar to the monomials:
\begin{verbatim}
BeginIntegrator
  Option = value
EndIntegrator
\end{verbatim}
with the following options available:
\begin{itemize}
\item {\ttfamily Tau}
\item {\ttfamily NumberOfTimescales}
\item {\ttfamily IntegrationStepsN = M} where {\ttfamily N} is the
  timescale (as integer value, counting starts from zero and goes up
  to the number of timescales minus 1) and {\ttfamily M} is the number
  of integration steps on that timescale. Note, that the integrators
  or defined recursively.
\item {\ttfamily LambdaN = F} where {\ttfamily N} is the
  timescale and {\ttfamily F} is a floating point number specifying
  the $\lambda$ value to be used on this timescale in case of the
  second order minimal norm integrator (2MN, 2MNPOSITION). The default
  value is $0.19$. Note, that $\lambda = 1/6$ is the Sexton-Weingarte
  scheme. 
\item {\ttfamily TypeN = TYPE}: set the type of integrator to be used
  on timescale {\ttfamily N}. The following types available:
  {\ttfamily 2MN, 2MNPOSITION, LEAPFROG}

  The position versions are not compatible with the velocity versions,
  thus they must not be used together.
\end{itemize}
A timescale must not be empty. Currently the maximal number of
timescales is $10$ and there cannot be more than $10$ monomials per
timescale. But there can be more than one monomial per timescale.

\subsection{Example Input File}

The following is a typical HMC input file:
\begin{verbatim}
L=8
T=16
Measurements = 1
startCondition = continue
#Startcondition = hot
beta = 3.30
2KappaMu = 0.03
kappa = 0.090
mubar = 1.
epsbar = 0.2

#This is a comment

PhmcRecEVInterval = 1
Nskip = 50
BCAngleT = 1.
BCGstabMaxIter = 5000
CGMaxIter = 1000
InitialStoreCounter = readin
UseEvenOdd = yes
PropagatorPrecision = 64
ReversibilityCheck = no
ReversibilityCheckIntervall = 1
DebugLevel = 3

PerformOnlineMeasurements = yes
OnlineMeasurementsFreq = 1

BeginMonomial GAUGE
  UseRectangleStaples = yes
  RectangleCoefficient = -0.0833333
  Timescale = 0
EndMonomial

BeginMonomial DET
  Timescale = 1
  2KappaMu = 0.
  kappa = 0.125
  AcceptancePrecision =  1.e-20
  ForcePrecision = 1.e-12
  Name = det
  solver   = cg
  CSGHistory = 10
  CSGHistory2 = 10
EndMonomial

BeginMonomial DETRATIO
  Timescale = 2
  2KappaMu = 0.03
  2KappaMu2 = 0.1
  kappa = 0.125
  kappa2 = 0.125
  maxiter = 20000
  AcceptancePrecision =  1.e-20
  ForcePrecision = 1.e-12
  Name = detrat
  solver = cg
EndMonomial

# this is a NDPOLY monomial
# but commented out
#BeginMonomial NDPOLY
#  Timescale = 1
#EndMonomial

BeginIntegrator 
  Type0 = 2MN
  Type1 = 2MN
  Type2 = 2MN
  IntegrationSteps0 = 1
  IntegrationSteps1 = 2
  IntegrationSteps2 = 3
  tau = 1.
  Lambda0 = 0.19
  NumberOfTimescales = 3
EndIntegrator
\end{verbatim}

For the inverter a typical file would look like
\begin{verbatim}
L=4
T=4
SolverFlag = cg
DebugLevel = 2
SolverPrecision = 1.e-14
InitialStoreCounter = 1
Indices = 0-7
ReadSource = no
Measurements = 1
mu = 0.0305
kappa = 0.15
BCAngleT = 1.
GaugeConfigInputFile = conf
UseEvenOdd = no
UseRelativePrecision=yes
SplittedPropagator = yes
SplittedSource = yes
PropagatorPrecision = 64
PropagatorType = DiracFermion_Source_Sink_Pairs
UseStoutSmearing = yes
StoutRho = 0.15
StoutNoIterations = 10
UseSloppyPrecision = yes
\end{verbatim}

\subsection{Reread functionality}

If you store a file with name {\ttfamily hmc.reread} in the working
directory of a running HMC, the program will read in this file after
the next finished trajectory. Then it will change the parameters
accordingly without the need of restarting the program. 

One cannot change from gauge action without rectangle part to gauge
action with rectangle part. If one wants to change $\mu$-,
$\epsilon^2$- or $N_i$-parameter one has to give allways all of
them. Otherwise the internal matching does not work and the program
will do nonsense.

The file will be deleted automatically, if it was used. A message will
be posted to standard output and to the file {\ttfamily
  history\_hmc\_tm} to let you identify the exact point where the
parameters changed.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
