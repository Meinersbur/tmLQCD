\section{Input parameter for main program}

The main programs are called {\ttfamily hmc\_tm} for the HMC algorithm
and {\ttfamily invert} for even odd preconditioned inversion. They can
be called with
\begin{itemize}
\item {\ttfamily -f filename}:\\
  where {\ttfamily filename} is the name of the input file to be
  used. The default name is {\ttfamily hmc.input}.

\item {\ttfamily -o name}:\\
  {\ttfamily name} will be used as name for several output files. This
  files differ by their suffix. Default for {\ttfamily name} is
  {\ttfamily output}.

\item {\ttfamily -?|-h}:\\
  This will produce help output and exit then.
  
\end{itemize}

There are several input parameters read from an input file. The parser is contained in the file {\ttfamily gwc/src/bin/read\_input.l}. The file {\ttfamily read\_input.l} is converted to {\ttfamily read\_input.c} using {\ttfamily flex} and defines the following function:

Definition:\\
\begin{ttfamily}
  int read\_input(char * conf\_file)
\end{ttfamily}\\

\begin{tabular}[h]{l l l}
{\ttfamily conf\_file} & in & string with input file name\\ 
\end{tabular}

The functions returns $0$, if no error occurs, $2$, if the input file
could not be opened. If no input file could be opened or if there is
no value given in the input file for a paramter, default values are
used. All default values can be found in the file {\ttfamily
  gwc/src/bin/default\_input\_values.h}. The syntax is allways
{\ttfamily keyword = value} and {\ttfamily keyword} must be at the
beginning of the line. Comments starting with {\ttfamily \#} and empty
lines are allowed. The order of the lines is not importand as long as
every keyword appears only once.  If it appears more than once, the
last appearance becomes valid. The parser is case-insensitive.

In the following a list of the currently (possibly incomplete)
supported input paramters: 
\begin{enumerate}
\item {\ttfamily T}:\\
  The global time extension of the lattice. Default is $4$.

\item {\ttfamily L}:\\
  The global spatial extension of the lattice. Default is $4$.

\item {\ttfamily NrXProcs}:\\
  The number of processors in x-direction in case of two dimensional
  parallelisation. This has no effect in case of one dimensional
  parallelisation. In case of two dimensional parallelisation it must
  be properly set. The number of processors in time direction is
  automatically computed.

\item {\ttfamily seed}:\\
  The seed for the random number generator. Default value is $123456$.

\item {\ttfamily beta}:\\
  The invers coupling $\beta$. Default value is $5.2$.

\item {\ttfamily kappa}:\\
  The $\kappa$ value. Default is $0.12$.

\item {\ttfamily RGIC1}:\\
  Coefficient $c_1$ for the rectangular part in the gauge
  action. Default value is $0$. $c_0$ is computed automatically with
  the correct normalization.

\item {\ttfamily Startcondition}:\\
  The starting condition for a run. Possible values are {\ttfamily
    hot, cold, restart, continue}. Default is {\ttfamily
    cold}. Restart uses the seed to reset the random number
  generator. For continue there must exist a state file for the random
  number generator. For both restart and continue there must exist a
  configuration file to start from. The file names must be set properly.

\item {\ttfamily Measurements}:\\
  Number of measurements in units of trajectories to be done. Default
  value is $3$. 

\item {\ttfamily Nskip}:\\
  Number of produced configurations to skip (i.e. not written to
  disk). Default value is $5$. 

\item {\ttfamily InitialStoreCounter}:\\
  Start with value to label measurements. Default is $0$. Can be also
  set to {\ttfamily readin} which causes to let the code check for a
  file {\ttfamily .nstore\_counter} and reads the initial value from
  this file. If it is not existing, the counter will be set to $0$.

\item {\ttfamily RlxdInputFile}:\\
  Name of input file for the double precision random number
  generator. Default is {\ttfamily last\_state}.

\item {\ttfamily GaugeConfigInputFile}:\\
  Name of input file for the gauge field. Default is {\ttfamily conf}

\item {\ttfamily mu}:\\
  Twisted mass parameter (the physical one) for twisted mass
  action. This is for internal reasons $2\kappa\mu$.

\item {\ttfamily mu2, mu3}:\\
  Additional masses (not physical) used for preconditioning. Default values are
  $0$. If set to a non zero value, additional pseudo fermion fields
  will be used.

\item {\ttfamily Indices=n-m}:\\
  Compute only components $n$ to $m$ of the quark propagator. $n,m$ must
  be in $[0,11]$. If the start index is not zero the data will be
  appended to the propagator file. The program takes not care of the
  order, the data is just appended! If the end index is equal to $11$
  also the two point functions are computed. This parameter has only
  effect for executable {\ttfamily invert}.

\item {\ttfamily SplittedPropagator}:\\
  If set to yes the propagators will written splitted to disk: one
  file per spinor color component. Default is {\ttfamily yes}.

\item {\ttfamily BCAngleT}:\\
  If generalized boundary conditions are enabled this set the angle in
  time direction to $\theta_t = 2\pi x$. Default value is
  zero. A value of $1$ would mean antiperiodic boundary conditions in
  time for the fermion fields.

\item {\ttfamily Integrator}:\\
  Determines the integration scheme to be used:
  \begin{itemize}
  \item {\ttfamily LeapFrog}: Simple leap frog algorithm with only one
    time scale. 
  \item {\ttfamily SextonWeingarten}: Sexton-Weingarten integration
    scheme with one time scale.
  \item {\ttfamily ExtLeapFrog}: leap frog integration scheme with
    multiple time scales.
  \item {\ttfamily ExtSextonWeingarten}: Sexton-Weingarten integration scheme with
    multiple time scales.
  \item {\ttfamily 2MN}: second order minimal norm with multiple time
    scales. (see {\ttfamily hep-lat/0505020} )
  \item {\ttfamily 2MNposition}: second order minimal norm with
    multiple time scales, but momentum and gauge update interchanged
    in the order.
  \end{itemize}

\item {\ttfamily Nsteps}:\\
  Number of molecular dynamic steps to be performed in the simple
  {\ttfamily LeapFrog} or the simple {\ttfamily SextonWeingarten}
  integrators. This keyword has no effect, if other integrators are
  used.

\item {\ttfamily dtau}:\\
  step size of molecular dynamic integration in the simple
  {\ttfamily LeapFrog} or the simple {\ttfamily SextonWeingarten}
  integrators. This keyword has no effect, if other integrators are
  used.

\item {\ttfamily tau}:\\
  Total length of the trajectory in case of a multiple time scale
  integration scheme ({\ttfamily ExtLeapFrog}, {\ttfamily
    ExtSextonWeingarten}, {\ttfamily 2MN} and {\ttfamily
    2MNposition}). This keyword has no effect, if other integrators
  are used.

\item {\ttfamily IntegrationStepsGauge}:\\
  Number of steps to be performed in the extented integration
  algorithms for the gauge action. This keyword has no effect, if
  other integrators are used.

\item {\ttfamily IntegrationStepsMu}:\\
  Number of steps to be performed in the extented integration
  algorithms for the action part with the smallest force
  contribution. Corresponds to the pseudo fermion action with the
  ratio of the physical operator with the precoditioning matrix with
  the smallest additional mass. This keyword has no effect, if
  other integrators are used.

\item {\ttfamily IntegrationStepsMu2}:\\
  Number of steps to be performed in the extented integration
  algorithms for the action part with the next to smallest force
  contribution. Corresponds to the pseudo fermion action with the
  ratio of the precoditioning matrix with the smallest additional mass
  with the operator with the next to smallest mass. This keyword has
  no effect, if other integrators are used.

\item {\ttfamily IntegrationStepsMu3}:\\
  Number of steps to be performed in the extented integration
  algorithms for the action part with the next to next to smallest force
  contribution. See above. This keyword has
  no effect, if other integrators are used.

\item {\ttfamily UseRelativePrecision}:\\
  Possible values {\ttfamily yes, no}. Indicates whether relative
  precision is used in the inversions for the force and the acceptance
  computation. Default is no.

\item {\ttfamily ForcePrecision}:\\
  Sets the squared residuum to be used in the force computation for
  all three $\mu$ values. This is used, if one of the following is not
  given.

\item {\ttfamily ForcePrecisionMu}:\\
  Sets the squared residuum to be used in the force computation for
  the inversions of $\mu$. Overwrites {\ttfamily ForcePrecision}
  for this force.

\item {\ttfamily ForcePrecisionMu2}:\\
  Sets the squared residuum to be used in the force computation for
  the inversions of $\mu_2$. Overwrites {\ttfamily ForcePrecision}
  for this force.

\item {\ttfamily ForcePrecisionMu3}:\\
  Sets the squared residuum to be used in the force computation for
  the inversions of $\mu_3$. Overwrites {\ttfamily ForcePrecision}
  for this force.

\item {\ttfamily AcceptancePrecision}:\\
  Sets the squared residuum to be used in the acceptance step for
  all three $\mu$ values. This is used, if one of the following is not
  given.

\item {\ttfamily AcceptancePrecisionMu}:\\
  Sets the squared residuum to be used in the acceptance step for
  the inversion with $\mu$.

\item {\ttfamily AcceptancePrecisionMu2}:\\
  Sets the squared residuum to be used in the acceptance step for
  the inversion with $\mu_2$.

\item {\ttfamily AcceptancePrecisionMu3}:\\
  Sets the squared residuum to be used in the acceptance step for
  the inversion with $\mu_3$.

\item {\ttfamily DebugLevel}:\\
  If set to a value larger than $0$ this causes verbose output:
  \begin{enumerate}
  \item forces are printed out.
  \end{enumerate}

\item {\ttfamily BCGstabMaxIter}:\\
  The maximal number of iterations in the BiCGstab solver.

\item {\ttfamily CGMaxIter}:\\
  The maximal number of iterations in the CG solver.

\item {\ttfamily ReversibilityCheck}:\\
  If set to {\ttfamily yes} the program will perform a check of
  reversibility violation in the integrator by integrating back in
  time. If not yet existing, the program creates a file {\ttfamily
    return\_check.data} in which it stores the reversibility violation
  as the difference in the Hamiltonian.

\item {\ttfamily ReversibilityCheckIntervall}:\\
  Here one can specify the intervall in terms of trajectories the
  program should check the reversibility violation.

\item {\ttfamily CSGHistoryMu}:\\
  The number of solutions of the Dirac equation to be saved for the
  physical $\mu$. If set to zero a zero spinor field is given as a
  first guess to the solver.
  
\item {\ttfamily CSGHistoryMu2}:\\
  The number of solutions of the Dirac equation to be saved for the
  first not physical $\mu_2$. If set to zero a zero spinor field is
  given as a first guess to the solver. 
 
\item {\ttfamily CSGHistoryMu2}:\\
  The number of solutions of the Dirac equation to be saved for the
  second not physical $\mu_3$. If set to zero a zero spinor field is
  given as a first guess to the solver.
  
\item {\ttfamily 2MNLambdaGauge}:\\
  The 2MN $\lambda$ parameter for the gauge time scale.

\item {\ttfamily 2MNLambdaMu|Mu2|Mu3}:\\
  The 2MN $\lambda$ parameters for the pseudo fermion time scales.

\end{enumerate}

\subsection{Reread functionality}

If you store a file with name {\ttfamily hmc.reread} in the working
directory of a running HMC, the program will read in this file after
the next finished trajectory. Then it will change the parameters
accordingly without the need of restarting the program. 

One cannot change from gauge action without rectangle part to gauge
action with rectangle part. If one wants to change $\mu$-,
$\epsilon^2$- or $N_i$-parameter one has to give allways all of
them. Otherwise the internal matching does not work and the program
will do nonsense.

The file will be deleted automatically, if it was used. A message will
be posted to standard output and to the file {\ttfamily
  history\_hmc\_tm} to let you identify the exact point where the
parameters changed.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
